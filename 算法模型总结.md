---
title: 算法模型总结
date: 2020-10-08 20:18:18
tags:
categories:
    - Algorithm
---

# 常用算法模板

## 排序

### 快速排序
``` cpp
void quick_sort(int nums[], int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1;
    int x = nums[l + r >> 1]; // nums[l]可能会死循环
    while (i < j) {
        while (nums[++i] < x);
        while (nums[--j] > x);
        if (i < j) swap(nums[i], nums[j]);
    }
    quick_sort(nums, l, j);
    quick_sort(nums, j + 1, r);
}
```

# 动态规划

## 数字三角形模型
* 问题原型：[数字三角形](https://www.acwing.com/problem/content/900/)
* 给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
* 二维空间无优化版
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 510;
int dp[N][N];
int n;

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j <= i; j++)
            cin >> dp[i][j];
    
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            if (j == 0) dp[i][j] += dp[i - 1][j];
            else if (j == i) dp[i][j] += dp[i - 1][j - 1];
            else dp[i][j] = max(dp[i][j] + dp[i - 1][j - 1], dp[i][j] + dp[i - 1][j]);
        }
    }
    
    int ans = -1e8;
    for (int i = 0; i < n; i++) ans = max(ans, dp[n - 1][i]);
    cout << ans << endl;
    return 0;
}
```

* 问题变形：
    1. [摘花生](https://www.acwing.com/problem/content/1017/)
    2. [最低通行费](https://www.acwing.com/problem/content/1020/)
    3. [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)
    4. [方格取数](https://www.acwing.com/problem/content/1029/)

### 方格取数
* 设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

* 思路：
之前的问题都是从某个点走到另一个点走一起，而这道题变成了走两次，对比一下两种的状态转移方程
走一次：$f[i, j]$表示所有从$(1, 1)$走到$(i, j)$的路径的最大值
走两次：$f[i1, j1, i2, j2]$表示所有从$(1, 1), (1, 1)$分别走到$(i1, j1), (i2, j2)$的路径的最大值。
不难发现只有在$i1 + j1 = i2 + j2$时，两条路径的格子才能重合，抽取两维状态变为$f(k, i1, i2)$其中$k$表示两条路线当前走到的格子的横纵坐标之和。$k = i1 + j1 = i2 + j2$
对应的$k - 1 = i1 + j1 - 1 = i2 + j2 - 1
<hr/>
状态转移方程：
$f[i1−1][j1][i2−1][j2]==f[k−1][i1−1][i2−1]$
$f[i1][j1−1][i2−1][j2]==f[k−1][i1][i2−1]$
$f[i1−1][j1][i2][j2−1]==f[k−1][i1−1][i2]$

​    

* 代码：
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 12;
int n;
int g[N][N], dp[N * 2][N][N];

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    int u, v, w;
    while (cin >> u >> v >> w && (u || v || w)) g[u][v] = w;
    for (int k = 2; k <= n + n; k++) {
        for (int i1 = 1; i1 <= n; i1++) {
            for (int i2 = 1; i2 <= n; i2++) {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n){
                    int t = g[i1][j1];
                    if (i1 != i2) t += g[i2][j2];
                    dp[k][i1][i2] = max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2 - 1] + t);
                    dp[k][i1][i2] = max(dp[k][i1][i2], dp[k - 1][i1 - 1][i2] + t);
                    dp[k][i1][i2] = max(dp[k][i1][i2], dp[k - 1][i1][i2 - 1] + t);
                    dp[k][i1][i2] = max(dp[k][i1][i2], dp[k - 1][i1][i2] + t);
                }
            }
        }
    }
    cout << dp[n + n][n][n] << endl;
    return 0;
}
```

## 最长上升子序列模型
* 问题原型：
给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:
>输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

说明:
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

* 代码:
``` cpp
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 0) return 0;
        int[] dp = new int[len];
        dp[0] = 1;

        int ans = 1;
        for (int i = 1; i < len; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    ans = Math.max(ans, dp[i]);
                }
            }
        }
        return ans;
    }
}
```

* 问题变形
    1. [怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)
    2. [登山](https://www.acwing.com/problem/content/1016/)
    3. [合唱队形](https://www.acwing.com/problem/content/484/) （与登山类似）
    4. [最大上升子序列和](https://www.acwing.com/problem/content/1018/)
    5. [拦截导弹](https://www.acwing.com/problem/content/description/1012/) （贪心 + LIS）
    6. [导弹防御系统](https://www.acwing.com/problem/content/189/) （dfs + LIS）

### 登山

* 题目描述：
五一到了，ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

* 输入格式
第一行包含整数N，表示景点数量。第二行包含N个整数，表示每个景点的海拔。

* 输出格式
输出一个整数，表示最多能浏览的景点数。

* 数据范围
$2≤N≤1000$
输入样例：
>8
186 186 150 200 160 130 197 220

输出样例：
>4

* 思路
枚举每个点，对于点$i$来说，它左边的最长上升子序列加上右边最长下降子序列是该点能参观景点的最大值，两遍的子序列会把该点加两次，需要减一

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n;
int a[N],dp[N][N];

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    
    for (int i = 0; i < n; i++) {
        dp[i][0] = 1;
        for (int j = 0; j < i; j++) {
            if (a[i] > a[j])
                dp[i][0] = max(dp[i][0], dp[j][0] + 1);
        }
    }
    
    for (int i = n - 1; i >= 0; i--) {
        dp[i][1] = 1;
        for (int j = n - 1; j > i; j--) {
            if (a[i] > a[j]) 
                dp[i][1] = max(dp[i][1], dp[j][1] + 1);
        }
    }
    
    int ans = 0;
    for (int i = 0 ; i < n; i++) {
        ans = max(ans, dp[i][0] + dp[i][1] - 1);
    }
    cout << ans << endl;
    return 0;
}
```

### 最长上升子序列和
* 题目描述
一个数的序列 $bi$，当 $b1 < b2 <… < bS$ 的时候，我们称这个序列是上升的。
对于给定的一个序列$(a1,a2,…,aN)$，我们可以得到一些上升的子序列$(ai1,ai2,…,aiK)$，这里$1 ≤ i_1 < i_2 < … < i_K ≤ N$。
比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。
这些子序列中和最大为18，为子序列(1,3,5,9)的和。
你的任务，就是对于给定的序列，求出最大上升子序列和。
注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。


* 思路
和最长上升子序列相同，只不过状态转移的时候记录的是和，而不是数量

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n;
int a[N], dp[N];

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    
    int ans = 0;
    for (int i = 0; i < n; i++) {
        dp[i] = a[i];
        for (int j = 0; j < i; j++) {
            if (a[i] > a[j]) 
                dp[i] = max(dp[i], dp[j] + a[i]);
        }
    }
    for (int i = 0; i < n; i++) ans = max(ans, dp[i]);
    cout << ans << endl;
    return 0;
}
```

### 拦截导弹
* 题目描述
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。
但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
某天，雷达捕捉到敌国的导弹来袭。
由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

* 思路
第一问是一个标准的LIS问题，逆着求或者正着求都可以
第二问求能覆盖整个数组的最长上升子序列的个数（贪心算法）
贪心：
用如下方式维护数组s，数组长度cnt，意为cnt个不下降子序列。保存的是每一个不上升子序列中的最后一个数：
遍历原序列，对于遍历到的每一个数x：
1. 若x大于s中每一个数，则新建一个不上升子序列，放入x;
2. 否则，找到s中大于等于x的最小的数，将其替换。
由于s每次增加长度时，增加的数必然大于其前面s中的任何一个数；且每次替换时，不改变x与被替换数左右相邻两数的相对大小关系，故s必然维持单调递增。则s即为原序列的最长上升子序列。

贪心算法的正确性：
设A为用该贪心算法得到的方案，B为最优解方案。记A的不上升子序列个数为la，B的不上升子序列个数为lb。
显然lb<=la（否则B就不是最优解）。
故只需证明la<=lb。用调整法(微调法)。
若A=B，则la=lb，显然成立。
否则（即A!=B），必然可以找到两方案中第一个(以原序列的顺序)不同之处（某数放在了不同的位置，且原序列中该数前的所有数在两方案中放的位置皆相同），将该数在两方案中所处的位置上的数(即该数本身)以及两位置之后方案中的序列相互对调，结果所得方案仍为合法解。即我们将贪心算法所得方案调整成了最优方案，且在调整过程中，方案的序列数没有增加，故la>=lb（la -> lb，且la转变为lb的过程中la的大小没有增加）。


* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int a[N], dp[N], g[N];

int main() {
    ios::sync_with_stdio(false);
    int n, idx = 0;
    while (cin >> n)
        a[idx++] = n;

    // 正序求最长非递增子序列
    int ans = 0;
    for (int i = 0; i < idx; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++)
            if (a[i] <= a[j])
                dp[i] = max(dp[i], dp[j] + 1);
        ans = max(ans, dp[i]);
    }
    
    int cnt = 0;
    for (int i = 0; i < idx; i++) {
        int k = 0;
        while (k < cnt && g[k] < a[i]) k++;
        g[k] = a[i];
        // 需要新增一个序列
        if (k >= cnt) cnt++;
    }
    for (int i = 0; i < cnt; i++) cout << g[i] << ' ';
    cout << ans << endl << cnt << endl;
    return 0;
}
```

### 导弹防御系统
* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 55;
int n, ans;
int a[N], up[N], down[N];

void dfs(int u, int su, int sd) {
    // 剪枝，当前位置的上升子序列加上下降子序列已经大于答案，不是要求的
    if (su + sd >= ans) return;
    if (u == n) {
        ans = su + sd;
        return;
    }
    
    int k = 0;
    while (k < su && a[u] <= up[k]) k++;
    int t = up[k];
    up[k] = a[u];
    if (k < su) dfs(u + 1, su, sd); // 存在一个子序列可以更新，所以su不用加1，直接往后递归一位
    else dfs(u + 1, su + 1, sd); // 需要新开一个子序列
    up[k] = t; // 回溯
    
    k = 0;
    while (k < sd && a[u] >= down[k]) k++;
    t = down[k];
    down[k] = a[u];
    if (k < sd) dfs(u + 1, su ,sd);
    else dfs(u + 1, su, sd + 1);
    down[k] = t; // 回溯
    
}

int main() {
    ios::sync_with_stdio(false);
    while (cin >> n && n) {
        for (int i = 0; i < n; i++) cin >> a[i];
        ans = n;
        dfs(0, 0, 0);
        cout << ans << endl;
    }
    return 0;    
}
```

## 背包模型

### 01背包
* 问题原型
有N件物品和一个容量是V的背包。每件物品只能使用一次。第i件物品的体积是$V_{i}$，价值是$W_{i}$。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int dp[N][N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (j < v[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << dp[n][m];
    return 0;
}
```

* 问题变形：
    1. [采药](https://www.acwing.com/problem/content/425/)
    2. [装箱问题](https://www.acwing.com/problem/content/1026/)
    3. [数字组合](https://www.acwing.com/problem/content/280/) （01背包求方案数）
    4. [背包问题求方案数](https://www.acwing.com/problem/content/11/) 
    5. [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

#### 分割等和子集
* 思路
1. 对数组中所有元素求和$sum$，如果不是偶数，那么根本不可能分成两堆相同的元素
2. 由于每个数只能选一次，所以是一个01背包问题，写一个01背包的模板，答案在哪找？ $dp[i]$意为背包中放入体积为i的最大价值，那么$dp[i] == i$说明有一组数能够组成i这个数

* 代码
``` cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size(), sum = 0;
        for (int i = 0; i < n; i++) sum += nums[i];

        if (sum % 2 == 1) return false;

        int target = sum / 2;
        int dp[target + 1];
        memset(dp, 0, sizeof dp);
        for (int i = 0; i < n; i++) {
            for (int j = target; j >= nums[i]; j--) 
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
        return dp[target] == target;
    }
};
```

### 完全背包
* 问题原型
有N种物品和一个容量是V的背包，每种物品都有无限件可用。第i种物品的体积是$V_{i}$，价值是$W_{i}$。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n, m;
int v[N], w[N];
int dp[N][N];

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= v[i])
                dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]);
        }
    }
    cout << dp[n][m] << endl;
    return 0;
}
```

* 问题变形：
    1. [货币系统](https://www.acwing.com/problem/content/1023/) （背包问题求方案数， 且注意和数字组合题的区别）

### 多重背包
* 问题原型
有N种物品和一个容量是V的背包。第i种物品最多有$S_{i}$件，每件体积是$V_{i}$，价值是$W_{i}$。
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;
int n, m;
int dp[N];

int main() {
    ios::sync_with_stdio(false);;
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        for (int j = m; j >= 0; j--) {
            for (int k = 1; k <= s && k * v <= j; k++) {
                dp[j] = max(dp[j], dp[j - k * v] + k * w);
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```

* 二进制优化
``` cpp
#include <bits/stdc++.h>
#define PII pair<int, int>
#define x first
#define y second

using namespace std;

const int N = 2010;
int dp[N];
int n, m;

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    
    vector<PII> goods;
    for (int i = 0; i < n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        for (int k = 1; k <= s; k *= 2) {
            s -= k;
            goods.push_back({k * v, k * w});
        }
        if (s > 0) goods.push_back({s * v, s * w});
    }
    for (auto g: goods) {
        for (int i = m; i >= g.x; i--) {
            dp[i] = max(dp[i], dp[i - g.x] + g.y);
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```

### 混合背包

### 二维费用的背包问题
* 问题原型：
有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。
每件物品只能用一次。体积是 $V_{i}$，重量是$M_{i}$，价值是 $W_{i}$。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。

* 代码：
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int dp[N][N];

int main() {
    ios::sync_with_stdio(false);
    int n, v, m;
    cin >> n >> v >> m;
    for (int i = 0; i < n; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = v; j >= a; j--) {
            for (int k = m; k >= b; k--) {
                dp[j][k] = max(dp[j][k], dp[j - a][k - b] + c);
            }
        }
    }
    cout << dp[v][m] << endl;
    return 0;
}
```

* 问题变形
    1. [潜水员](https://www.acwing.com/problem/content/1022/)


#### 潜水员
这道题与普通的二维费用背包问题不一样
* 普通的二维费用背包问题状态转移方程
``` cpp
for(int j =  V;j >= v;j --)
    for(int k = M;k >= m;k --)
        f[j][k] = max(f[j][k], f[j - v][k - m] + w);
```
* 本题的状态转移方程
``` cpp
for(int j = V;j >= 0;j --)
    for(int k = M;k >= 0;k --)
        f[j][k] = min(f[j][k], f[max(0, j - v)][max(0, k - m)] + w);
```

* 两者产生差别的原因：普通的二维费用背包问题求的是：不超过体积V，重量M的前提下，所能拿到的最大价值，所以枚举体积和重量的时候不用超过给定的限定；本体的要求是：至少需要体积V，重量M的前提下，能拿到的最小价值，物品所多出来的体积或者重量并不关心，我们的目的是求最小价值，所以去枚举所有的情况

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int m, n, k;
int dp[N][N];

int main() {
    cin >> n >> m >> k;
    memset(dp, 0x3f, sizeof dp);
    dp[0][0] = 0;
    for (int i = 0; i < k; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = n; j >= 0; j--) {
            for (int k = m; k >= 0; k--) {
                dp[j][k] = min(dp[j][k], dp[max(0, j - a)][max(0, k - b)] + c);
            }
        }
    }
    cout << dp[n][m] << endl;
    return 0;
}
```


### 分组背包
* 问题原型
有N组物品和一个容量是V的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$V_{ij}$，价值是$W_{ij}$，其中i是组号j是组内编号。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
输出最大价值。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;
int dp[N],v[N], w[N];

int main() {
    ios::sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    for (int i = 0 ; i < n; i++) {
        int s;
        cin >> s;
        for (int j = 0 ; j < s; j++) cin >> v[j] >> w[j];
        for (int j = m; j >= 0; j--) 
            for (int k = 0; k < s; k++) {
                if (j - v[k] >= 0)
                    dp[j] = max(dp[j], dp[j - v[k]] + w[k]);
            }
    }
    cout << dp[m] << endl;
    return 0;
}
```

* 有依赖的背包问题


## 状态压缩DP

### 棋盘式（基于连通性）

#### 小国王
* 在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。
* 思路

* 代码
``` cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

typedef long long LL;
const int N = 12, S = (1 << N);

LL f[N][N * N][S];  // f[i][j][s] 第i行已经，共摆j个国王，i状态是s
int n, m;
int cnt[S];  // 每个状态里面1的个数
vector<int> state;  // 状态集
vector<int> head[S];  // 每个状态可以转移到的其他状态

// 存在连续一返回false
bool check(int x){
    return !(x & (x >> 1));  // 如果存在连续1，那么x & x >> 1必定等于全1（所有位），取反的话必定等于0
    // 如果不存在连续1的话，右移一位刚好错开，x & x >> 1必定为0,取反为1
}

// 统计状态x的国王数
int count(int x){
    int ans = 0;
    for(int i = 0; i < n; i ++)
        ans += (x >> i & 1);
    return ans;
}

int main(){
    cin >> n >> m;

    // 预处理阶段1：同行合法化
    for(int i = 0; i <(1 << n); i ++){
        if(check(i)){  // 是否存在连续1，如果不存在的话
            state.push_back(i);  // i合法
            cnt[i] = count(i);  // 统计一下这个状态每一行有多少国王
        }
    }

    // 预处理阶段2：相邻行合法化
    // 枚举所有状态
    for(int i = 0; i < state.size(); i ++){
        for(int j = 0; j < state.size(); j ++){
            int a = state[i];
            int b = state[j];
            if((a & b) == 0 && check(a | b))  // 相邻行不能在同一个位置有国王，并且不能在攻击范围有
                head[i].push_back(j);  // 如果这两个状态可以满足条件即可以做邻居
        }
    }

    f[0][0][0] = 1;  // 方案数为1

    // dp过程
    for(int i = 1; i <= n + 1; i ++)  // 枚举n行
        for(int j = 0; j <= m; j ++)  // 枚举国王数
            for(int a = 0; a < state.size(); a ++)  // 枚举所有行合法状态
                for(int b = 0; b < head[a].size(); b ++){  // 枚举所有行相邻合法状态,只有行相邻合法才能从前一行转移过来
                    int c = cnt[state[a]];  // 第i行的所有行合法状态国王数
                    if(j >= c)  // 可以继续放国王
                        f[i][j][a] += f[i - 1][j - c][head[a][b]];  // 从i-1行转移过来
                }

    cout << f[n + 1][m][0] << endl;  // n + 1行什么都不放，相当于只在1~n行放国王
    return 0;

}
```

#### 玉米田
* [题目连接](https://www.acwing.com/problem/content/329/)
* 问题描述：
农夫约翰的土地由M*N个小方格组成，现在他要在土地里种植玉米。非常遗憾，部分土地是不育的，无法种植。而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。

* 思路
和上一题小国王十分相似，只是放置的位置有了限制。
$dp[i, j]$表示放置了前$i$行且第$i$的状态是$s$的方案数。
假设$a$是第$i - 1$行的状态，$b$是第$i$行的状态，题目所限制的放法是不能十字形放置，所以状态$a & b == 0$才是合法的方案
题目中有特定的土地不能够种植，维护一个数组$g[i]$意味第$i$行不能种植土地的状态，比如$1010$表示第一个和第三个位置不能够种植，
那么第$i$行的状态为$b & g[i] == 0$

* 代码：
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 14, M = 1 << 12, mod = 1e8;
int m, n;
int g[N];
vector<int> state;
vector<int> head[M];
int dp[N][M];

// 判断x状态所表示的选法中是否有连续的1
bool check(int x) {
    for (int i = 0; i < m; i++)
        if ((x >> i & 1) && (x >> i + 1 & 1))
            return false;
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    
    // 输入图
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < m; j++) {
            int t;
            cin >> t;
            // 反转之后方便做与运算
            g[i] += !t << j;
        }
    }
    
    // 枚举所有可选的状态
    for (int i = 0; i < 1 << m; i++) {
        if (check(i)) 
            state.push_back(i);
    }
    
    for (int i = 0; i < state.size(); i++) {
        for (int j = 0; j < state.size(); j++) {
            int a = state[i], b = state[j];
            if ((a & b) == 0) 
                head[i].push_back(j);
        }
    }
    
    dp[0][0] = 1;
    for (int i = 1; i <= n + 1; i++) {
        for (int a = 0; a < state.size(); a++) {
            for (int b: head[a]) {
                if (g[i] & state[a]) continue;
                dp[i][a] = (dp[i][a] + dp[i - 1][b]) % mod;
            }
        }
    }
    cout << dp[n + 1][0] << endl;
    return 0;
}
```
### 集合式

#### 最短Hamilton路径
* [题目链接](https://www.acwing.com/problem/content/93/)
* 给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。

* 思路
如果该题用暴搜，时间复杂度是阶乘，必超时，所以采取状态压缩进行优化
每个点有选和不选两种状态，数据范围提示不会超过20个点，枚举$2^{20}$种状态
$dp(i, j)$表示当前选了i个点，且最后的状态停留在第j个点，那么当前的状态是由上一种状态选了i - 1个点，并且最后停留在k，加上点k到j的距离
前一维的状态可以用二进制位运算来记录选了哪些点

* 代码：
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 21, M = 1 << N;
int n;
int g[N][N];
int dp[M][N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++) 
            cin >> g[i][j];
            
    memset(dp, 0x3f, sizeof dp);
    // 起点在0，0点，状态初始化为0
    dp[1][0] = 0;
    // 第一重循环枚举所有0到2^n次方种选取情况
    for (int i = 0; i < 1 << n; i++) {
        // 第二重循环枚举当前停留在哪个点
        for (int j = 0; j < n; j++) {
            // 只有i的二进制位为1才表示这个点选过，选过的点才可以作为最后一个停留点
            if (i >> j & 1) {
                // 第三重循环枚举上一个状态停留在哪个点
                for (int k = 0; k < n; k++) {
                    // i - (1 << j) >> k & 1 
                    // 排除当前停留的点，当前停留的点不应该在上一个状态中出现
                    // 在枚举上一个状态中停留的最后一个点
                    if (i - (1 << j) >> k & 1) {
                        dp[i][j] = min(dp[i][j], dp[i - (1 << j)][k] + g[k][j]);
                    }
                }
            }
        }
    }
    cout << dp[(1 << n) - 1][n - 1] << endl;
    return 0;
}
```

#### 蒙德里安的梦想
* [题目链接](https://www.acwing.com/problem/content/293/)
* 求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。

例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。

* 思路
本题等价于找到所有横放 1 X 2 小方格的方案数，因为所有横放确定了，那么竖放方案是唯一的。
用$f[i][j]$记录第$i$列第$j$个状态。$j$状态位等于1表示上一列有横放格子，本列有格子捅出来。转移方程很简单，本列的每一个状态都由上列所有“合法”状态转移过来$f[i][j] += f[i - 1][k]$
两个转移条件： i 列和 i - 1列同一行不同时捅出来 ； 本列捅出来的状态j和上列捅出来的状态k求或，得到上列是否为奇数空行状态，奇数空行不转移。
初始化条件$f[0][0] = 1$，第0列只能是状态0，无任何格子捅出来。返回$f[m][0]$。第$m + 1$列不能有东西捅出来。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int N = 12, M = 1 << N;
ll dp[N][M];
bool st[M];

int main() {
    ios::sync_with_stdio(false);
    int n, m;
    while (cin >> n >> m && (n || m)) {
        for (int i = 0; i < 1 << n; i++) {
            int cnt = 0;
            st[i] = 1;
            for (int j = 0; j < n; j++) {
                if (i >> j & 1) {
                    if (cnt & 1) st[i] = false;
                    cnt = 0;
                } else cnt++;
            }
            if (cnt & 1) st[i] = false;
        }
        memset(dp, 0, sizeof dp);
        dp[0][0] = 1;
        for (int i = 1; i <= m; i++) 
            for (int j = 0; j < 1 << n; j++) 
                for (int k = 0; k < 1 << n; k++) {
                    if ((j & k) == 0 && (st[j | k]))
                        dp[i][j] += dp[i - 1][k];
                }
        cout << dp[m][0] << endl;
    }
    
    return 0;
}
```

## 区间DP
* 区间dp常用模板
所有的区间dp问题，第一维都是枚举区间长度，一般 len = 1 用来初始化，枚举从 len = 2 开始，第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）
``` cpp
for (int i = 1; i <= n; i++) {
    dp[i][i] = 初始值
}
for (int len = 2; len <= n; len++)           //区间长度
    for (int i = 1; i + len - 1 <= n; i++) { //枚举起点
        int j = i + len - 1;                 //区间终点
        for (int k = i; k < j; k++) {        //枚举分割点，构造状态转移方程
            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
```

* 问题举例：石子合并
设有N堆石子排成一排，其编号为1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；

如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

* 思路
最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并
$dp[i][j]$表示将$i$到$j$合并成一堆的最小方案的集合
状态转移：
当$i < j$时，$dp[i][j] = $min (dp[i][i], dp[i][k] + dp[k + 1][r] + s[j] - s[i - 1])
当$i == j$时，$dp[i][j] = 0$（合并同一堆石子的代价为0）

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 310;
int n;
int a[N], s[N];
int dp[N][N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i], s[i] = s[i - 1] + a[i];
    
    // 枚举长度
    for (int len = 2; len <= n; len++) {
        // 枚举左边界，从而知道长度和左边届可以推出右边界
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            dp[l][r] = 0x3f3f3f3f;
            for (int k = l; k < r; k++) {
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]);
            }
        }
    }
    cout << dp[1][n] << endl;
    return 0;
}
```

### 环形石子合并
* 问题描述
将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：

* 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。
* 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。

* 思路
题目把石子做成了环形，所以我们不能使用链式的解决方式。
所以我们需要断环，把数组复制为原来的两倍，做链式的区间dp，最后答案去查找长度为n的区间

* 代码：
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 410, INF = 0x3f3f3f3f;
int n;
int a[N], s[N];
int f[N][N], g[N][N];

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        a[i + n] = a[i];
        
    }
    for (int i = 1; i <= 2 * n; i++) {
        s[i] = s[i - 1] + a[i];
    }
    
    memset(f, INF, sizeof f);
    memset(g, -INF, sizeof g);
    
    for (int len = 1; len <= n; len++) {
        for (int l = 1; l + len - 1 <= n * 2; l++) {
            int r = l + len - 1;
            if (len == 1) f[l][r] = g[l][r] = 0;
            else {
                for (int k = l; k < r; k++) {
                    f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
                    g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]);
                }
            }
        }
    }
    
    int ans_min = INF, ans_max = -INF;
    for (int i = 1; i <= n; i++) {
        ans_min = min(ans_min, f[i][i + n - 1]);
        ans_max = max(ans_max, g[i][i + n - 1]);
    }
    cout << ans_min << endl << ans_max << endl;
    return 0;
}
```

* 问题变形：
    1. [能量项链](https://www.acwing.com/problem/content/322/) （注意状态转移方程和普通区间DP略有不同）

## 树形DP

### 树的重心
* [题目链接](https://www.acwing.com/problem/content/848/)
* 题目描述
给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

* 思路
每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
vector<int> g[N];
int n, ans = 0x3f3f3f;
int d[N]; // 以i为根节点最大子树的数目

void dfs(int u, int fa) {
    d[u] = 1;
    int mx = 0;
    for (int next: g[u]) {
        if (next != fa) {
            dfs(next, u);
            d[u] += d[next];
            mx = max(mx, d[next]);
        }
    }
    mx = max(mx, n - d[u]);
    ans = min(ans, mx);
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, -1);
    cout << ans << endl;
    return 0;
}
```

### 树的最长路径
* 题目描述
给定一棵树，树中包含 n 个结点（编号1~n）和 n−1 条无向边，每条边都有一个权值。

现在请你找到树中的一条最长路径。

换句话说，要找到一条路径，使得使得路径两端的点的距离最远。

注意：路径中可以只包含一个点。

* 思路
和求树的直径类似，此题中给出的图带权值，解法上略有不同。
先回忆一下树的直径怎么求的：先选取一点找到离该点最远的点，在以最远的点为起点找其最远的点，这条路的距离就是树的直径。
同样的方法，随机选取一点，以点1为例，那么通过该点的最大距离应该分别为子树到达叶节点的最大值和次大值的和

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e4 + 10;
int n, ans;
vector<vector<int>> g[N];

int dfs(int u, int fa) {
    int dist = 0; // 表示从当前点往下走的最大长度
    int d1 = 0, d2 = 0;
    for (auto next: g[u]) {
        if (next[0] == fa) continue;
        int d = dfs(next[0], u) + next[1];
        dist = max(dist, d);
        if (d >= d1) d2 = d1, d1 = d;
        else if (d > d2) d2 = d;
    }
    ans = max(ans, d1 + d2);
    return dist;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    dfs(1, -1);
    cout << ans << endl;
    return 0;
}
```

## 数位DP
* $[X, Y]$之间满足的个数转换成$Y$满足条件的个数减去$X$满足条件的个数
* 从树的角度去分析问题

* 数位DP模板
``` cpp
int dp(int n)
{
    if (!n) return 0;

    vector<int> nums;
    while(n) nums.push_back(n % B), n /= B;  // B进制下把每一位抠出来 低 - > 高

    int res = 0;
    int last = 0; // 右边信息的前缀的信息 此题为 前面有多少个1

    for(int i = nums.size() - 1; i >= 0; i --)  // 从高位开始枚举 并分类讨论 
    {
        int x = nums[i];  
        // 左边的分支
        if(x)  //  讨论 第i位的取值情况
        {

        }
    }

    return res;
}
```

### 数字游戏
科协里最近很流行数字游戏。

某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。

现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 15;
int f[N][10];

int init() {
    for (int i = 0; i <= 9; i++) f[1][i] = 1;
    for (int i = 2; i < N; i++) {
        for (int j = 0; j <= 9; j++) {
            for (int k = j; k <= 9 ;k++) {
                f[i][j] += f[i - 1][k];
            }
        }
    }
}

int dp(int n) {
    if (!n) return 1;
    
    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;
    
    int res = 0, last = 0;
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        for (int j = last; j < x; j++) 
            res += f[i + 1][j];
            
        if (x < last) break;
        last = x;
        
        if (!i) res++;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    init();
    int l, r;
    while (cin >> l >> r) cout << dp(r) - dp(l - 1) << endl;
    return 0;
}
```

### Windy数
Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 2 的正整数被称为 Windy 数。

Windy 想知道，在 A 和 B 之间，包括 A 和 B，总共有多少个 Windy 数？

* 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 15;
int f[N][10];

void init() {
    for (int i = 0; i <= 9; i++) f[1][i] = 1;
    for (int i = 2; i < N; i++) {
        for (int j = 0; j <= 9; j++) {
            for (int k = 0; k <= 9; k++) {
                if (abs(j - k) >= 2)
                    f[i][j] += f[i - 1][k];
            }
        }
    }
    
    return ;
}

int dp(int n) {
    if (!n) return 0;
    
    int ans = 0, last = -2;
    
    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;
    
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        for (int j = i == nums.size() - 1; j < x; j++)
            if (abs(j - last) >= 2)
                ans += f[i + 1][j];
              
        if (abs(x - last) >= 2) last = x;
        else break;
        
        if (!i) ans++;
    }
    
    for (int i = 1; i < nums.size(); i++) {
        for (int j = 1; j <= 9; j++) {
            ans += f[i][j];
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    init();
    
    int l, r;
    cin >> l >> r;
    cout << dp(r) - dp(l - 1) << endl;
    
    return 0;
}
```

# 广度优先搜索

## Flood Fill
* 泛洪算法，染色连通块

### 池塘计数
农夫约翰有一片 N∗M 的矩形土地。
最近，由于降雨的原因，部分土地被水淹没了。
现在用一个字符矩阵来表示他的土地。
每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。
现在，约翰想知道他的土地中形成了多少片池塘。
每组相连的积水单元格集合可以看作是一片池塘。
每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。
请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

* 代码
``` cpp
#include <bits/stdc++.h>
#define PII pair<int, int>
#define x first
#define y second

using namespace std;

const int N = 1010;
int n, m, ans;
char g[N][N];
bool st[N][N];

void bfs(int sx, int sy) {
    queue<PII> q;
    q.push({sx, sy});
    while (!q.empty()) {
        auto curr = q.front();
        q.pop();
        
        // 八连通的枚举方式，枚举一个3 * 3的矩阵，再挖去中间的点
        // 四联通可以用方向数组枚举方向
        for (int i = curr.x - 1; i <= curr.x + 1; i++) {
            for (int j = curr.y - 1; j <= curr.y + 1; j++) {
                if (i == curr.x && j == curr.y) continue;
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                
                q.push({i, j});
                st[i][j] = 1;
            }
        }
        
    }
    return ;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> g[i];
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (g[i][j] == 'W' && !st[i][j]) {
                bfs(i, j);
                ans ++;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 山峰和山谷
FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。

为了能够对旅程有一个安排，他想知道山峰和山谷的数量。

给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。
我们定义一个格子的集合 S 为山峰（山谷）当且仅当：
1. S 的所有格子都有相同的高度。
2. S 的所有格子都连通。
3. 对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws > ws′（山峰），或者 ws < ws′（山谷）。
如果周围不存在相邻区域，则同时将其视为山峰和山谷。
你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。

* 代码
``` cpp
#include <bits/stdc++.h>
#define PII pair<int, int>
#define x first
#define y second

using namespace std;
using ll = long long;

const int N = 1010;
int n;
int g[N][N];
bool st[N][N];

void bfs(int sx, int sy, bool &has_higher, bool &has_lower) {
    queue<PII> q;
    q.push({sx, sy});
    st[sx][sy] = 1;
    while (!q.empty()) {
        PII curr = q.front();
        q.pop();
        int x = curr.x, y = curr.y;
        for (int i = x - 1; i <= x + 1; i++) {
            for (int j = y - 1; j <= y + 1; j++) {
                if (i == x && j == y) continue; // 八连通扣去中间点
                if (i < 0 || j < 0 || i >= n || j >= n) continue; // 边界处理
                // 判断周围是否有比该连通块高或者低的点
                if (g[i][j] != g[x][y]) {
                    if (g[i][j] > g[x][y]) has_higher = true;
                    else has_lower = true;
                } else if (!st[i][j]) {
                    q.push({i, j});
                    st[i][j] = 1;
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++) 
            cin >> g[i][j];
            
    int peak = 0, low = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (!st[i][j]) {
                bool has_higher = false, has_lower = false;
                bfs(i, j, has_higher, has_lower);
                if (!has_higher) peak ++;
                if (!has_lower) low++;
            }
        }
    }
    cout << peak << ' ' << low << endl;    
    return 0;
}
```

## 最短路模型

### 迷宫问题
给定一个 n×n 的二维数组，如下所示：

>int maze[5][5] = {
0, 1, 0, 0, 0,
0, 1, 0, 1, 0,
0, 0, 0, 0, 0,
0, 1, 1, 1, 0,
0, 0, 0, 1, 0,
};


它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。
数据保证至少存在一条从左上角走到右下角的路径。

* 代码
``` cpp
#include <bits/stdc++.h>
#define PII pair<int, int>
#define x first
#define y second

using namespace std;

const int N = 1010;
int n;
int g[N][N];
PII pre[N][N]; // 存储的是上一个点的位置
bool st[N][N];
int di[4] = {-1, 0, 1, 0}, dj[4] = {0, -1, 0, 1};

void bfs(int sx, int sy) {
    queue<PII> q;
    q.push({sx, sy});
    st[sx][sy] = 1;
    while (!q.empty()) {
        PII curr = q.front();
        q.pop();
        
        for (int d = 0; d < 4; d++) {
            int px = curr.x + di[d];
            int py = curr.y + dj[d];
            if (px < 0 || py < 0 || px >= n || py >= n || g[px][py] == 1) continue;
            if (st[px][py]) continue;
            q.push({px, py});
            pre[px][py] = curr;
            st[px][py] = 1;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 0; i < n; i++) 
        for (int j = 0 ; j < n; j++) 
            cin >> g[i][j];
            

    PII point = {0, 0};
    bfs(n - 1, n - 1);
    while (1) {
        if (point.x == n - 1 && point.y == n - 1) {
            cout << n - 1 << ' ' << n - 1 << endl;
            break;
        } else {
            cout << point.x << ' ' << point.y << endl;
            point = pre[point.x][point.y];
        }
    }
    
    return 0;
}
```

## 多源BFS

## 最小步数

## 双端队列广搜

## 双向广搜